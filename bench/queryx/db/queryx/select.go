// Code generated by queryx, DO NOT EDIT.

package queryx

import (
	"fmt"
	"strings"
)

type SelectStatement struct {
	selection []string
	from      string
	where     *Clause
	limit     *int
	offset    *int
	order     []string
	group     string
	having    string
	distinct  []string
	joins     []string
}

func NewSelect() *SelectStatement {
	return &SelectStatement{}
}

func (s *SelectStatement) Select(selection ...string) *SelectStatement {
	s.selection = selection
	return s
}

func (s *SelectStatement) From(from string) *SelectStatement {
	s.from = from
	return s
}

func (s *SelectStatement) Where(clauses ...*Clause) *SelectStatement {
	if len(clauses) == 0 {
		return s
	}

	if s.where == nil {
		s.where = clauses[0].And(clauses[1:]...)
	} else {
		s.where = s.where.And(clauses...)
	}

	return s
}

func (s *SelectStatement) Limit(limit int) *SelectStatement {
	s.limit = &limit
	return s
}

func (s *SelectStatement) Offset(offset int) *SelectStatement {
	s.offset = &offset
	return s
}

func (s *SelectStatement) Order(order ...string) *SelectStatement {
	s.order = append(s.order, order...)
	return s
}

func (s *SelectStatement) Distinct(distinct ...string) *SelectStatement {
	s.distinct = distinct
	return s
}

func (s *SelectStatement) GroupBy(group string) *SelectStatement {
	s.group = group
	return s
}

func (s *SelectStatement) Having(having string) *SelectStatement {
	s.having = having
	return s
}

func (s *SelectStatement) Join(join ...string) *SelectStatement {
	s.joins = append(s.joins, join...)
	return s
}

// convert select statement to update statement
func (s *SelectStatement) Update() *UpdateStatement {
	if s.limit != nil {
		return NewUpdate().Table(s.from).Where(s.where) // TODO: convert into subquery
	}
	return NewUpdate().Table(s.from).Where(s.where)
}

// convert select statement to delete statement
func (s *SelectStatement) Delete() *DeleteStatemnet {
	return NewDelete().From(s.from).Where(s.where)
}

func (s *SelectStatement) ToSQL() (string, []interface{}) {
	var query string
	if len(s.distinct) > 0 {
		query = fmt.Sprintf("SELECT DISTINCT  %s FROM %s", strings.Join(s.distinct, ", "), s.from)
	} else {
		query = fmt.Sprintf("SELECT %s FROM %s", strings.Join(s.selection, ", "), s.from)
	}
	args := []interface{}{}

	if len(s.joins) > 0 {
		for i := 0; i < len(s.joins); i++ {
			query = fmt.Sprintf("%s %s", query, s.joins[i])
		}
	}

	if s.where != nil {
		query = fmt.Sprintf("%s WHERE %s", query, s.where.fragment)
		args = append(args, s.where.args...)
	}

	if s.group != "" {
		query = fmt.Sprintf("%s GROUP BY %s", query, s.group)
	}

	if s.having != "" {
		query = fmt.Sprintf("%s HAVING %s", query, s.having)
	}

	if s.order != nil {
		query = fmt.Sprintf("%s ORDER BY %s", query, strings.Join(s.order, ", "))
	}

	if s.limit != nil {
		query = fmt.Sprintf("%s LIMIT ?", query)
		args = append(args, *s.limit)
	}

	if s.offset != nil {
		query = fmt.Sprintf("%s OFFSET ?", query)
		args = append(args, *s.offset)
	}

	return query, args
}
