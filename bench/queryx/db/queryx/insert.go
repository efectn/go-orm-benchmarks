// Code generated by queryx, DO NOT EDIT.

package queryx

import (
	"fmt"
	"strings"
)

type InsertStatement struct {
	into       string
	columns    []string
	values     [][]interface{}
	returning  []string
	onConflict string
}

func NewInsert() *InsertStatement {
	return &InsertStatement{}
}

func (s *InsertStatement) Into(into string) *InsertStatement {
	s.into = into
	return s
}

func (s *InsertStatement) Columns(columns ...string) *InsertStatement {
	s.columns = columns
	return s
}

func (s *InsertStatement) Values(values ...interface{}) *InsertStatement {
	if len(values) > 0 {
		s.values = append(s.values, values)
	}
	return s
}
func (s *InsertStatement) Returning(returning ...string) *InsertStatement {
	s.returning = returning
	return s
}

func (s *InsertStatement) OnConflict(onConflict string) *InsertStatement {
	s.onConflict = onConflict
	return s
}

func (s *InsertStatement) ToSQL() (string, []interface{}) {
	sql := fmt.Sprintf("INSERT INTO %s", s.into)

	if len(s.columns) > 0 {
		sql = fmt.Sprintf("%s(\"%s\")", sql, strings.Join(s.columns, "\", \""))
	} else {
		sql = fmt.Sprintf("%s DEFAULT VALUES", sql)
	}
	values := []string{}
	for _, v := range s.values {
		ss := []string{}
		for range v {
			ss = append(ss, "?")
		}
		values = append(values, fmt.Sprintf("(%s)", strings.Join(ss, ", ")))
	}
	if len(values) > 0 {
		sql = fmt.Sprintf("%s VALUES %s", sql, strings.Join(values, ", "))
	}

	if len(s.returning) > 0 {
		sql = fmt.Sprintf("%s RETURNING %s", sql, strings.Join(s.returning, ", "))
	}

	if s.onConflict != "" {
		sql = fmt.Sprintf("%s %s", sql, s.onConflict)
	}

	args := []interface{}{}
	for _, v := range s.values {
		args = append(args, v...)
	}

	return sql, args
}
